{
    "sourceFile": "pkg/bot/bot.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1706905152077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1706906371497,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-package pkg\r\n+package bot\r\n \r\n import (\r\n \t\"fmt\"\r\n \t\"log\"\r\n"
                },
                {
                    "date": 1706943863027,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,22 +1,70 @@\n package bot\r\n \r\n import (\r\n+\t\"flag\"\r\n \t\"fmt\"\r\n \t\"log\"\r\n \t\"os\"\r\n \t\"os/signal\"\r\n \t\"strings\"\r\n+\t\"time\"\r\n \r\n \t\"github.com/bwmarrin/discordgo\"\r\n )\r\n \r\n-var BotToken string\r\n+var (\r\n+\tGuildID        = flag.String(\"guild\", \"\", \"Test guild ID. If not passed - bot registers commands globally\")\r\n+\tBotToken       = flag.String(\"token\", \"\", \"Bot access token\")\r\n+\tRemoveCommands = flag.Bool(\"rmcmd\", true, \"Remove all commands after shutdowning or not\")\r\n+)\r\n \r\n+\r\n+// Utility function to create an embed in response to an interaction\r\n+func create_embed(name string, session *discordgo.Session, interaction *discordgo.InteractionCreate, description string, Fields []*discordgo.MessageEmbedField) {\r\n+\tembed := &discordgo.MessageEmbed{\r\n+\t\tAuthor:      &discordgo.MessageEmbedAuthor{},\r\n+\t\tColor:       0xFFE41E,\r\n+\t\tDescription: description,\r\n+\r\n+\t\tTimestamp: time.Now().Format(time.RFC3339), // Discord wants ISO8601; RFC3339 is an extension of ISO8601 and should be completely compatible.\r\n+\t\tTitle:     name,\r\n+\t\tFields:    Fields,\r\n+\t}\r\n+\r\n+\t// Send the embed as a response to the provided interaction\r\n+\tsession.InteractionRespond(interaction.Interaction, &discordgo.InteractionResponse{Type: discordgo.InteractionResponseChannelMessageWithSource, Data: &discordgo.InteractionResponseData{\r\n+\t\tEmbeds: []*discordgo.MessageEmbed{embed},\r\n+\t}})\r\n+}\r\n+\r\n+// Utility function to create an embed in response to an interaction\r\n+func send_embed(name string, session *discordgo.Session, user string, description string, Fields []*discordgo.MessageEmbedField) {\r\n+\tembed := &discordgo.MessageEmbed{\r\n+\t\tAuthor:      &discordgo.MessageEmbedAuthor{},\r\n+\t\tColor:       0xFFE41E,\r\n+\t\tDescription: description,\r\n+\r\n+\t\tTimestamp: time.Now().Format(time.RFC3339), // Discord wants ISO8601; RFC3339 is an extension of ISO8601 and should be completely compatible.\r\n+\t\tTitle:     name,\r\n+\t\tFields:    Fields,\r\n+\t}\r\n+\r\n+\t// Send the embed as a response to the provided interaction\r\n+\tchannel, err := session.UserChannelCreate(user)\r\n+\r\n+\tif err != nil {\r\n+\t\tfmt.Println(err)\r\n+\t} else {\r\n+\t\tsession.ChannelMessageSendEmbed(channel.ID, embed)\r\n+\t}\r\n+}\r\n+\r\n+\r\n func Run() {\r\n \r\n \t// create a session\r\n-\tdiscord, err := discordgo.New(\"Bot \" + BotToken)\r\n+\tdiscord, err := discordgo.New(\"Bot \" + *BotToken)\r\n \tif err != nil {\r\n \t\tlog.Fatalf(\"Bot broken\")\r\n \t\tos.Exit(1)\r\n \t}\r\n"
                }
            ],
            "date": 1706905152077,
            "name": "Commit-0",
            "content": "package pkg\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"os\"\r\n\t\"os/signal\"\r\n\t\"strings\"\r\n\r\n\t\"github.com/bwmarrin/discordgo\"\r\n)\r\n\r\nvar BotToken string\r\n\r\nfunc Run() {\r\n\r\n\t// create a session\r\n\tdiscord, err := discordgo.New(\"Bot \" + BotToken)\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Bot broken\")\r\n\t\tos.Exit(1)\r\n\t}\r\n\r\n\t// add a event handler\r\n\tdiscord.AddHandler(newMessage)\r\n\r\n\t// open session\r\n\tdiscord.Open()\r\n\tdefer discord.Close() // close session, after function termination\r\n\r\n\t// keep bot running untill there is NO os interruption (ctrl + C)\r\n\tfmt.Println(\"Bot running....\")\r\n\tc := make(chan os.Signal, 1)\r\n\tsignal.Notify(c, os.Interrupt)\r\n\t<-c\r\n\r\n}\r\n\r\nfunc newMessage(discord *discordgo.Session, message *discordgo.MessageCreate) {\r\n\r\n\t/* prevent bot responding to its own message\r\n\tthis is achived by looking into the message author id\r\n\tif message.author.id is same as bot.author.id then just return\r\n\t*/\r\n\tif message.Author.ID == discord.State.User.ID {\r\n\t\treturn\r\n\t}\r\n\r\n\t// respond to user message if it contains `!help` or `!bye`\r\n\tswitch {\r\n\tcase strings.Contains(message.Content, \"!help\"):\r\n\t\tdiscord.ChannelMessageSend(message.ChannelID, \"Hello WorldðŸ˜ƒ\")\r\n\tcase strings.Contains(message.Content, \"!bye\"):\r\n\t\tdiscord.ChannelMessageSend(message.ChannelID, \"Good ByeðŸ‘‹\")\r\n\t\t// add more cases if required\r\n\t}\r\n\r\n}\r\n"
        }
    ]
}
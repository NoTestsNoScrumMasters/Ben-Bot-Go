{
    "sourceFile": "pkg/bot/bot.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1706905152077,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1706906371497,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-package pkg\r\n+package bot\r\n \r\n import (\r\n \t\"fmt\"\r\n \t\"log\"\r\n"
                },
                {
                    "date": 1706943863027,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,22 +1,70 @@\n package bot\r\n \r\n import (\r\n+\t\"flag\"\r\n \t\"fmt\"\r\n \t\"log\"\r\n \t\"os\"\r\n \t\"os/signal\"\r\n \t\"strings\"\r\n+\t\"time\"\r\n \r\n \t\"github.com/bwmarrin/discordgo\"\r\n )\r\n \r\n-var BotToken string\r\n+var (\r\n+\tGuildID        = flag.String(\"guild\", \"\", \"Test guild ID. If not passed - bot registers commands globally\")\r\n+\tBotToken       = flag.String(\"token\", \"\", \"Bot access token\")\r\n+\tRemoveCommands = flag.Bool(\"rmcmd\", true, \"Remove all commands after shutdowning or not\")\r\n+)\r\n \r\n+\r\n+// Utility function to create an embed in response to an interaction\r\n+func create_embed(name string, session *discordgo.Session, interaction *discordgo.InteractionCreate, description string, Fields []*discordgo.MessageEmbedField) {\r\n+\tembed := &discordgo.MessageEmbed{\r\n+\t\tAuthor:      &discordgo.MessageEmbedAuthor{},\r\n+\t\tColor:       0xFFE41E,\r\n+\t\tDescription: description,\r\n+\r\n+\t\tTimestamp: time.Now().Format(time.RFC3339), // Discord wants ISO8601; RFC3339 is an extension of ISO8601 and should be completely compatible.\r\n+\t\tTitle:     name,\r\n+\t\tFields:    Fields,\r\n+\t}\r\n+\r\n+\t// Send the embed as a response to the provided interaction\r\n+\tsession.InteractionRespond(interaction.Interaction, &discordgo.InteractionResponse{Type: discordgo.InteractionResponseChannelMessageWithSource, Data: &discordgo.InteractionResponseData{\r\n+\t\tEmbeds: []*discordgo.MessageEmbed{embed},\r\n+\t}})\r\n+}\r\n+\r\n+// Utility function to create an embed in response to an interaction\r\n+func send_embed(name string, session *discordgo.Session, user string, description string, Fields []*discordgo.MessageEmbedField) {\r\n+\tembed := &discordgo.MessageEmbed{\r\n+\t\tAuthor:      &discordgo.MessageEmbedAuthor{},\r\n+\t\tColor:       0xFFE41E,\r\n+\t\tDescription: description,\r\n+\r\n+\t\tTimestamp: time.Now().Format(time.RFC3339), // Discord wants ISO8601; RFC3339 is an extension of ISO8601 and should be completely compatible.\r\n+\t\tTitle:     name,\r\n+\t\tFields:    Fields,\r\n+\t}\r\n+\r\n+\t// Send the embed as a response to the provided interaction\r\n+\tchannel, err := session.UserChannelCreate(user)\r\n+\r\n+\tif err != nil {\r\n+\t\tfmt.Println(err)\r\n+\t} else {\r\n+\t\tsession.ChannelMessageSendEmbed(channel.ID, embed)\r\n+\t}\r\n+}\r\n+\r\n+\r\n func Run() {\r\n \r\n \t// create a session\r\n-\tdiscord, err := discordgo.New(\"Bot \" + BotToken)\r\n+\tdiscord, err := discordgo.New(\"Bot \" + *BotToken)\r\n \tif err != nil {\r\n \t\tlog.Fatalf(\"Bot broken\")\r\n \t\tos.Exit(1)\r\n \t}\r\n"
                },
                {
                    "date": 1707028176378,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,10 +57,132 @@\n \t\tsession.ChannelMessageSendEmbed(channel.ID, embed)\r\n \t}\r\n }\r\n \r\n-func Run() {\r\n \r\n+\r\n+\"github.com/Southclaws/cj/types\"\r\n+)\r\n+\r\n+const cmdUsage = \"USAGE: /wiki [function/callback]\"\r\n+\r\n+type Results struct {\r\n+\tStatus struct {\r\n+\t\tTotal      int `json:\"total\"`\r\n+\t\tFailed     int `json:\"failed\"`\r\n+\t\tSuccessful int `json:\"successful\"`\r\n+\t} `json:\"status\"`\r\n+\tRequest struct {\r\n+\t\tQuery struct {\r\n+\t\t\tQuery string `json:\"query\"`\r\n+\t\t} `json:\"query\"`\r\n+\t\tSize      int `json:\"size\"`\r\n+\t\tFrom      int `json:\"from\"`\r\n+\t\tHighlight struct {\r\n+\t\t\tStyle  interface{} `json:\"style\"`\r\n+\t\t\tFields interface{} `json:\"fields\"`\r\n+\t\t} `json:\"highlight\"`\r\n+\t\tFields           interface{} `json:\"fields\"`\r\n+\t\tFacets           interface{} `json:\"facets\"`\r\n+\t\tExplain          bool        `json:\"explain\"`\r\n+\t\tSort             []string    `json:\"sort\"`\r\n+\t\tIncludeLocations bool        `json:\"includeLocations\"`\r\n+\t\tSearchAfter      interface{} `json:\"search_after\"`\r\n+\t\tSearchBefore     interface{} `json:\"search_before\"`\r\n+\t} `json:\"request\"`\r\n+\tHits      []Hit       `json:\"hits\"`\r\n+\tTotalHits int         `json:\"total\"`\r\n+\tTook      int64       `json:\"took\"`\r\n+}\r\n+\r\n+type Hit struct {\r\n+\tUrl                  string  `json:\"url\"`\r\n+\tTitle                string  `json:\"title\"`\r\n+\tDescription          string  `json:\"desc\"`\r\n+\tTitleFragments       string  `json:\"title_fragment\"`\r\n+\tDescriptionFragments string  `json:\"desc_fragment\"`\r\n+\tScore                float64 `json:\"score\"`\r\n+}\r\n+\r\n+func (cm *CommandManager) commandWiki(\r\n+\tinteraction *discordgo.InteractionCreate,\r\n+\targs map[string]*discordgo.ApplicationCommandInteractionDataOption,\r\n+\tsettings types.CommandSettings,\r\n+) (\r\n+\tcontext bool,\r\n+\terr error,\r\n+) {\r\n+\tsearchTerm := args[\"search-term\"].StringValue()\r\n+\tif len(searchTerm) < 3 {\r\n+\t\tcm.replyDirectly(interaction, \"Query must be 3 characters or more\")\r\n+\t\treturn\r\n+\t}\r\n+\r\n+\tr, err := http.Get(fmt.Sprintf(\"https://api.open.mp/docs/search?q=%s\", strings.ReplaceAll(searchTerm, \" \", \"%20\")))\r\n+\tif err != nil {\r\n+\t\tcm.replyDirectly(interaction, fmt.Sprintf(\"Failed to GET result for search term %s\\nError: %s\", searchTerm, err.Error()))\r\n+\t\treturn\r\n+\t}\r\n+\r\n+\tvar results Results\r\n+\tif err = json.NewDecoder(r.Body).Decode(&results); err != nil {\r\n+\t\tcm.replyDirectly(interaction, fmt.Sprintf(\"Failed to decode result for search term %s\\nError: %s\\n\", searchTerm, err.Error()))\r\n+\t\treturn\r\n+\t}\r\n+\r\n+\tif results.TotalHits == 0 {\r\n+\t\tcm.replyDirectlyEmbed(interaction, \"\", &discordgo.MessageEmbed{\r\n+\t\t\tType:        discordgo.EmbedTypeRich,\r\n+\t\t\tTitle:       fmt.Sprintf(\"No results: %s\", searchTerm),\r\n+\t\t\tDescription: \"There were no results for that query.\",\r\n+\t\t})\r\n+\t\treturn\r\n+\t}\r\n+\r\n+\tdesc := strings.Builder{}\r\n+\r\n+\trendered := 0\r\n+\tfor _, hit := range results.Hits {\r\n+\t\tif rendered == 3 {\r\n+\t\t\tbreak\r\n+\t\t}\r\n+\r\n+\t\t// Skip searching translations\r\n+\t\tif strings.Contains(hit.Url, \"translations\") {\r\n+\t\t\tcontinue\r\n+\t\t}\r\n+\r\n+\t\tdesc.WriteString(fmt.Sprintf(\r\n+\t\t\t\"[%s](https://open.mp/%s): %s\\n\",\r\n+\t\t\thit.Title,\r\n+\t\t\tstrings.TrimSuffix(hit.Url, \".md\"),\r\n+\t\t\tformatDescription(hit)))\r\n+\t\trendered++\r\n+\t}\r\n+\tembed := &discordgo.MessageEmbed{\r\n+\t\tType:        discordgo.EmbedTypeRich,\r\n+\t\tTitle:       fmt.Sprintf(\"Documentation Search Results: %s\", searchTerm),\r\n+\t\tDescription: desc.String(),\r\n+\t}\r\n+\tcm.replyDirectlyEmbed(interaction, \"\", embed)\r\n+\r\n+\treturn false, err // Todo: remove this\r\n+}\r\n+\r\n+func formatDescription(hit Hit) string {\r\n+\tif len(hit.Description) == 0 {\r\n+\t\treturn \"(No description found)\"\r\n+\t}\r\n+\r\n+\treturn html.UnescapeString(strings.ReplaceAll(\r\n+\t\tstrings.ReplaceAll(\r\n+\t\t\thit.Description,\r\n+\t\t\t\"<mark>\", \"**\"),\r\n+\t\t\"</mark>\", \"**\"))\r\n+}\r\n+\r\n+func Run(BotToken string) {\r\n+\r\n \t// create a session\r\n \tdiscord, err := discordgo.New(\"Bot \" + *BotToken)\r\n \tif err != nil {\r\n \t\tlog.Fatalf(\"Bot broken\")\r\n"
                },
                {
                    "date": 1707028197342,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,13 +57,8 @@\n \t\tsession.ChannelMessageSendEmbed(channel.ID, embed)\r\n \t}\r\n }\r\n \r\n-\r\n-\r\n-\"github.com/Southclaws/cj/types\"\r\n-)\r\n-\r\n const cmdUsage = \"USAGE: /wiki [function/callback]\"\r\n \r\n type Results struct {\r\n \tStatus struct {\r\n"
                }
            ],
            "date": 1706905152077,
            "name": "Commit-0",
            "content": "package pkg\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"log\"\r\n\t\"os\"\r\n\t\"os/signal\"\r\n\t\"strings\"\r\n\r\n\t\"github.com/bwmarrin/discordgo\"\r\n)\r\n\r\nvar BotToken string\r\n\r\nfunc Run() {\r\n\r\n\t// create a session\r\n\tdiscord, err := discordgo.New(\"Bot \" + BotToken)\r\n\tif err != nil {\r\n\t\tlog.Fatalf(\"Bot broken\")\r\n\t\tos.Exit(1)\r\n\t}\r\n\r\n\t// add a event handler\r\n\tdiscord.AddHandler(newMessage)\r\n\r\n\t// open session\r\n\tdiscord.Open()\r\n\tdefer discord.Close() // close session, after function termination\r\n\r\n\t// keep bot running untill there is NO os interruption (ctrl + C)\r\n\tfmt.Println(\"Bot running....\")\r\n\tc := make(chan os.Signal, 1)\r\n\tsignal.Notify(c, os.Interrupt)\r\n\t<-c\r\n\r\n}\r\n\r\nfunc newMessage(discord *discordgo.Session, message *discordgo.MessageCreate) {\r\n\r\n\t/* prevent bot responding to its own message\r\n\tthis is achived by looking into the message author id\r\n\tif message.author.id is same as bot.author.id then just return\r\n\t*/\r\n\tif message.Author.ID == discord.State.User.ID {\r\n\t\treturn\r\n\t}\r\n\r\n\t// respond to user message if it contains `!help` or `!bye`\r\n\tswitch {\r\n\tcase strings.Contains(message.Content, \"!help\"):\r\n\t\tdiscord.ChannelMessageSend(message.ChannelID, \"Hello WorldðŸ˜ƒ\")\r\n\tcase strings.Contains(message.Content, \"!bye\"):\r\n\t\tdiscord.ChannelMessageSend(message.ChannelID, \"Good ByeðŸ‘‹\")\r\n\t\t// add more cases if required\r\n\t}\r\n\r\n}\r\n"
        }
    ]
}